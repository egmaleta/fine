// PARSER GRAMMAR

module: glob_defn_list

glob_defn_list: glob_defn_list glob_defn
              | glob_defn

?glob_defn: _LET _name _ASSIGN _internal                        -> int_val_defn
          | _LET _name param_list _ASSIGN _internal             -> int_fun_defn
          | _LET ID _operator ID _ASSIGN _internal              -> int_op_defn
          | _DATA TYPE_ID param_list? _ASSIGN _INTERNAL         -> int_adt_defn
          | _DATA TYPE_ID param_list? _ASSIGN _BAR? adt_ct_list -> adt_defn
          | defn

adt_ct_list: adt_ct_list _BAR adt_ct
           | adt_ct

adt_ct: TYPE_ID ( _COLON fun_type_arg )?

fun_type_arg: type_arg _ARROW fun_type_arg
            | type_arg

?type_arg: var_type_arg
         | null_type_arg
         | ( var_type_arg | null_type_arg ) type_arg_list -> poly_type_arg
         | _OPAR fun_type_arg _CPAR

var_type_arg: ID

null_type_arg: TYPE_ID

type_arg_list: type_arg_list type_arg
             | type_arg

_internal: _INTERNAL ID

?defn: _LET _name _ASSIGN _expr              -> val_defn
     | _LET _name param_list _ASSIGN _expr   -> fun_defn
     | _LET ID _operator ID _ASSIGN _expr    -> op_defn
     | _LET _name _COLON fun_type_arg        -> typeof_defn
     | ( INFIXL | INFIXR ) NAT operator_list -> fix_defn

_name: ID
     | _OPAR ( LARGE_OP | OP ) _CPAR

operator_list: operator_list _operator
             | _operator

_operator: _BTICK ID _BTICK
         | LARGE_OP
         | OP

param_list: param_list ID
          | ID

_expr: _BSLASH param_list _ASSIGN _expr                -> func_expr
     | defn_list _IN _expr                             -> let_expr
     | _MATCH _expr _OCURLY match_list _COMMA? _CCURLY -> match_expr
     | operand ( _operator operand )*                  -> op_chain_expr

defn_list: defn_list defn
         | defn

match_list: match_list _COMMA match
          | match

match: pattern _ARROW _expr

?pattern: ID+                         -> data_pattern
        | ( DEC | NAT | BOOL | UNIT ) -> literal_pattern

operand: operand atom
       | atom

?atom: _OPAR _expr _CPAR -> expr_atom
     | _name             -> id_atom
     | literal

?literal: DEC  -> dec_literal
        | NAT  -> nat_literal
        | BOOL -> bool_literal
        | UNIT -> unit_literal

// LEXER GRAMMAR

_INTERNAL.1: "#internal" // over COMMENT
COMMENT: /#[^\n]*/

TYPE_ID: /[A-Z][a-zA-Z0-9_]*/

// keywords (all over ID)
INFIXL.2: "infixl" // over IN
INFIXR.2: "infixr" // over IN
_IN.1: "in"
_LET.1: "let"
_MATCH.1: "match"
_DATA.1: "data"
BOOL.1: "true" | "false"

ID: /[a-z_][a-zA-Z0-9_]*/

DEC: /(0|[1-9][0-9]*)\.[0-9]*/
NAT: /0|[1-9][0-9]*/

_BTICK: "`"
_BSLASH: "\\"
_COMMA: ","
_OCURLY: "{"
_CCURLY: "}"

_ARROW.1: "->" // over LARGE_OP
LARGE_OP: /[~!@$%^&*\/\-+|?.<>:=]{2,3}/
_ASSIGN: "="
_BAR: "|"
_COLON: ":"
OP: /[~!@$%^&*\/\-+?.<>]/

UNIT: "()"

_OPAR: "("
_CPAR: ")"

SPACE: /[ \t\f\r\n]+/

%ignore COMMENT
%ignore SPACE
