// PARSER GRAMMAR

module: defn_list

defn_list: defn_list defn
         | defn

localdefn_list: localdefn_list localdefn
              | localdefn

?defn: _TYPE _typename ( _OPAR param_list _CPAR )? _OCURLY _INTERNAL _CCURLY   -> int_datatype
     | _TYPE _typename ( _OPAR param_list _CPAR )? _OCURLY datact_list _CCURLY -> datatype
     | _LET _name _COLON type_scheme                                           -> typing
     | _LET _name ( _OPAR fun_param_list _CPAR )? _ASSIGN _internal            -> int_binding
     | _LET fun_param _operator fun_param _ASSIGN _internal                    -> int_operation
     | localdefn

?localdefn: ( INFIXL | INFIXR | INFIX ) INT operator_list           -> fixity
          | _LET _name ( _OPAR fun_param_list _CPAR )? _ASSIGN expr -> binding
          | _LET fun_param _operator fun_param _ASSIGN expr         -> operation

datact_list: datact_list datact
           | datact

datact: CAP_ID _COLON type_scheme

type_scheme: ( _FORALL ID+ DOT )? fun_type

fun_type: type ( ARROW fun_type )?

?type: type_var
     | type_const
     | type_app
     | _OPAR fun_type _CPAR

type_var: ID

type_const: _typename

type_app: ( type_var | type_const ) _OPAR targ_list _CPAR

targ_list: targ_list _COMMA fun_type
         | fun_type

_internal: _INTERNAL ID

_typename: CAP_ID
         | _OPAR ARROW _CPAR

_name: ID
     | _OPAR ( LARGE_OP | OP | DOT ) _CPAR

operator_list: operator_list _operator
             | _operator

_operator: _BTICK ID _BTICK
         | LARGE_OP
         | OP
         | DOT

param_list: param_list _COMMA ID
          | ID

fun_param_list: fun_param_list _COMMA fun_param
              | fun_param

fun_param: LAZY ID
         | ID

?expr: _BSLASH _OPAR fun_param_list _CPAR ARROW expr             -> fun_expr
     | localdefn_list _IN expr                                   -> let_expr
     | _IF expr _THEN expr ( _ELIF expr _THEN expr )* _ELSE expr -> guard_expr
     | operand ( _operator operand )*                            -> op_chain_expr

?pattern: ID                                 -> capture_pattern
        | CAP_ID ( _OPAR param_list _CPAR )? -> data_pattern
        | ( FLOAT | INT | UNIT | STRING )    -> literal_pattern

?operand: operand _OPAR expr_list _CPAR          -> fun_app
        | _MATCH expr _OCURLY match_list _CCURLY -> match_expr
        | ( CAP_ID | _name )                     -> id_atom
        | _OPAR expr _CPAR
        | literal

expr_list: expr_list _COMMA expr
         | expr

match_list: match_list match
          | match

match: pattern ARROW expr

?literal: FLOAT  -> dec_literal
        | INT    -> nat_literal
        | UNIT   -> unit_literal
        | STRING -> string_literal


// LEXER GRAMMAR

CAP_ID: /[A-Z][a-zA-Z0-9_']*/

_INTERNAL: "%internal"
_ELIF: "elif"
_ELSE: "else"
_FORALL: "forall"
INFIXL: "infixl"
INFIXR: "infixr"
INFIX: "infix"
_IF: "if"
_IN: "in"
LAZY: "lazy"
_LET: "let"
_MATCH: "match"
_THEN: "then"
_TYPE: "type"

ID: /[a-z_][a-zA-Z0-9_']*/

%import common.ESCAPED_STRING -> STRING

FLOAT: /-?(0|[1-9][0-9]*)\.[0-9]*/
INT: /-?(0|[1-9][0-9]*)/

_BTICK: "`"
_BSLASH: "\\"
_COMMA: ","
_OCURLY: "{"
_CCURLY: "}"

ARROW: "->"
LARGE_OP: /[~!@$%^&*\/\-+|?.<>:=]{2,3}/

DOT: "."
_COLON: ":"
_ASSIGN: "="
OP: /[~!@$%^&*\/\-+|?<>]/

UNIT: "(" _SPACE? ")"
_OPAR: "("
_CPAR: ")"

%import common.WS -> _SPACE
%import common.SH_COMMENT -> _COMMENT

%ignore _COMMENT
%ignore _SPACE
