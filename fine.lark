// PARSER GRAMMAR

module: defn_list

defn_list: defn_list defn
         | defn

localdefn_list: localdefn_list localdefn
              | localdefn

?defn: _TYPE _typename param_list? _OCURLY _INTERNAL _CCURLY         -> int_datatype
     | _TYPE _typename param_list? _OCURLY _BAR? datact_list _CCURLY -> datatype
     | _LET _name _COLON type_scheme                                 -> typing
     | _LET _name fun_param_list? _ASSIGN _internal                  -> int_binding
     | _LET fun_param _operator fun_param _ASSIGN _internal          -> int_operation
     | localdefn

?localdefn: ( INFIXL | INFIXR | INFIX ) INT operator_list   -> fixity
          | _LET _name fun_param_list? _ASSIGN expr         -> binding
          | _LET fun_param _operator fun_param _ASSIGN expr -> operation

datact_list: datact_list _BAR datact
           | datact

datact: CAP_ID _COLON type_scheme

type_scheme: ( _FORALL param_list DOT )? fun_type

fun_type: type ( ARROW fun_type )?

?type: type_var
     | type_const
     | type_app
     | _OPAR fun_type _CPAR

type_var: ID

type_const: _typename

type_app: ( type_var | type_const ) targ_list

targ_list: targ_list targ
         | targ

?targ: type_var
     | type_const
     | _OPAR type_app _CPAR
     | _OPAR fun_type _CPAR

_internal: _INTERNAL ID

_typename: CAP_ID
         | _OPAR ARROW _CPAR

_name: ID
     | _OPAR ( LARGE_OP | OP | DOT ) _CPAR

operator_list: operator_list _operator
             | _operator

_operator: _BTICK ID _BTICK
         | LARGE_OP
         | OP
         | DOT

param_list: param_list ID
          | ID

fun_param_list: fun_param_list fun_param
              | fun_param

fun_param: _OPAR LAZY ID _CPAR
         | ID

?expr: _BSLASH fun_param_list ARROW expr                         -> fun_expr
     | localdefn_list _IN expr                                   -> let_expr
     | _IF expr _THEN expr ( _ELIF expr _THEN expr )* _ELSE expr -> guard_expr
     | operand ( _operator operand )*                            -> op_chain_expr

?pattern: ID                              -> capture_pattern
        | CAP_ID param_list?              -> data_pattern
        | ( FLOAT | INT | UNIT | STRING ) -> literal_pattern

?operand: operand atom -> fun_app
        | atom

?atom: _MATCH expr _OCURLY _BAR? match_list _CCURLY -> match_expr
     | ( CAP_ID | _name )                           -> id_atom
     | _OPAR expr _CPAR
     | literal

match_list: match_list _BAR match
          | match

match: pattern ARROW expr

?literal: FLOAT  -> dec_literal
        | INT    -> nat_literal
        | UNIT   -> unit_literal
        | STRING -> string_literal


// LEXER GRAMMAR

CAP_ID: /[A-Z][a-zA-Z0-9_']*/

_INTERNAL: "%internal"
_ELIF: "elif"
_ELSE: "else"
_FORALL: "forall"
INFIXL: "infixl"
INFIXR: "infixr"
INFIX: "infix"
_IF: "if"
_IN: "in"
LAZY: "lazy"
_LET: "let"
_MATCH: "match"
_THEN: "then"
_TYPE: "type"

ID: /[a-z_][a-zA-Z0-9_']*/

%import common.ESCAPED_STRING -> STRING

FLOAT: /-?(0|[1-9][0-9]*)\.[0-9]*/
INT: /-?(0|[1-9][0-9]*)/

_BTICK: "`"
_BSLASH: "\\"
_OCURLY: "{"
_CCURLY: "}"

ARROW: "->"
LARGE_OP: /[~!@$%^&*\/\-+|?.<>:=]{2,3}/

DOT: "."
_COLON: ":"
_ASSIGN: "="
_BAR: "|"
OP: /[~!@$%^&*\/\-+?<>]/

UNIT: "(" _SPACE? ")"
_OPAR: "("
_CPAR: ")"

%import common.WS -> _SPACE
%import common.SH_COMMENT -> _COMMENT

%ignore _COMMENT
%ignore _SPACE
