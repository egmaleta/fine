// PARSER GRAMMAR

module: defn+

?defn: _DATA CAP_ID param_list? _OCURLY _INTERNAL _CCURLY   -> int_data_defn
     | _DATA CAP_ID param_list? _OCURLY datact_list _CCURLY -> data_defn
     | _LET _name fun_param_list? _ASSIGN _internal         -> int_val_defn
     | _LET fun_param _operator fun_param _ASSIGN _internal -> int_op_defn
     | fix_defn
     | typeof_defn
     | val_defn
     | op_defn

fix_defn: ( INFIXL | INFIXR | INFIX ) INT _operator+

typeof_defn: _LET _name _COLON type_scheme

val_defn: _LET _name fun_param_list? _ASSIGN expr

op_defn: _LET fun_param _operator fun_param _ASSIGN expr

datact_list: datact+

datact: CAP_ID ( _COLON fun_type )?

type_scheme: ( _FORALL type_var_list DOT )? fun_type

type_var_list: ID+

fun_type: type ( _ARROW type )*

?type: ( type_var | type_const ) _OPAR fun_type ( _COMMA fun_type )* _CPAR -> type_app
     | type_var
     | type_const
     | _OPAR fun_type _CPAR

type_var: ID

type_const: CAP_ID

_internal: _INTERNAL ID

_name: ID
     | _OPAR ( LARGE_OP | OP | DOT ) _CPAR

_operator: _BTICK ID _BTICK
         | LARGE_OP
         | OP
         | DOT

param_list: _OPAR ID ( _COMMA ID )* _CPAR

fun_param_list: _OPAR fun_param ( _COMMA fun_param )* _CPAR

fun_param: LAZY? ID

?expr: _BSLASH fun_param_list _ARROW expr                        -> fun_expr
     | ( typeof_defn | val_defn | op_defn | fix_defn )+ _IN expr -> let_expr
     | _IF expr _THEN expr ( _ELIF expr _THEN expr )* _ELSE expr -> guard_expr
     | operand ( _operator operand )*                            -> op_chain_expr

match: pattern _ARROW expr

?pattern: ID                              -> capture_pattern
        | CAP_ID param_list?              -> data_pattern
        | ( FLOAT | INT | UNIT | STRING ) -> literal_pattern

?operand: operand _OPAR expr_list _CPAR      -> fun_app
        | ( CAP_ID | _name )                 -> id_atom
        | _MATCH expr _OCURLY match+ _CCURLY -> match_expr
        | _OPAR expr _CPAR
        | literal

expr_list: expr ( _COMMA expr )*

?literal: FLOAT  -> dec_literal
        | INT    -> nat_literal
        | UNIT   -> unit_literal
        | STRING -> string_literal


// LEXER GRAMMAR

CAP_ID: /[A-Z][a-zA-Z0-9_]*/

_INTERNAL: "%internal"
_DATA: "data"
_ELIF: "elif"
_ELSE: "else"
_FORALL: "forall"
INFIXL: "infixl"
INFIXR: "infixr"
INFIX: "infix"
_IF: "if"
_IN: "in"
LAZY: "lazy"
_LET: "let"
_MATCH: "match"
_THEN: "then"

ID: /[a-z_][a-zA-Z0-9_]*/

%import common.ESCAPED_STRING -> STRING

FLOAT: /-?(0|[1-9][0-9]*)\.[0-9]*/
INT: /-?(0|[1-9][0-9]*)/

_BTICK: "`"
_BSLASH: "\\"
_COMMA: ","
_OCURLY: "{"
_CCURLY: "}"

_ARROW: "->"
LARGE_OP: /[~!@$%^&*\/\-+|?.<>:=]{2,3}/

DOT: "."
_COLON: ":"
_ASSIGN: "="
OP: /[~!@$%^&*\/\-+|?<>]/

UNIT: "(" _SPACE? ")"
_OPAR: "("
_CPAR: ")"

%import common.WS -> _SPACE
%import common.SH_COMMENT -> _COMMENT

%ignore _COMMENT
%ignore _SPACE
