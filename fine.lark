// PARSER GRAMMAR

module: defn+

?defn: _DATA CAP_ID param_list? _OCURLY _INTERNAL _CCURLY   -> int_data_defn
     | _DATA CAP_ID param_list? _OCURLY datact_list _CCURLY -> data_defn
     | _name param_list? _ASSIGN _internal                  -> int_val_defn
     | ID _operator ID _ASSIGN _internal                    -> int_op_defn
     | local_defn

datact_list: datact+

datact: CAP_ID _COLON quantified_type

quantified_type: ( _FORALL param_list )? fun_type

fun_type: type ( _ARROW type )*

?type: ID                                                -> type_var
     | CAP_ID                                            -> type_const
     | ( ID | CAP_ID ) _OPAR type ( _COMMA type )* _CPAR -> type_app
     | _OPAR quantified_type _CPAR

_internal: _INTERNAL ID

?local_defn: ( INFIXL | INFIXR ) NAT _operator -> fix_defn
           | _name _COLON quantified_type      -> typeof_defn
           | _name param_list? _ASSIGN expr    -> val_defn
           | ID _operator ID _ASSIGN expr      -> op_defn

_name: ID
     | _OPAR ( LARGE_OP | OP ) _CPAR

_operator: _BTICK ID _BTICK
         | LARGE_OP
         | OP

param_list: _OPAR ID ( _COMMA ID )* _CPAR

?expr: _BSLASH param_list _ASSIGN expr    -> fun_expr
     | _LET local_defn+ _IN expr          -> let_expr
     | _MATCH expr _OCURLY match+ _CCURLY -> match_expr
     | operand ( _operator operand )*     -> op_chain_expr

match: pattern _ARROW expr

?pattern: ID                   -> capture_pattern
        | CAP_ID param_list?   -> data_pattern
        | ( DEC | NAT | UNIT ) -> literal_pattern

?operand: operand _OPAR expr_list _CPAR -> fun_app
        | ( CAP_ID | _name )            -> id_atom
        | _OPAR expr _CPAR
        | literal

expr_list: expr ( _COMMA expr )*

?literal: DEC  -> dec_literal
        | NAT  -> nat_literal
        | UNIT -> unit_literal


// LEXER GRAMMAR

_INTERNAL.1: "#internal" // over COMMENT
COMMENT: /#[^\n]*/

CAP_ID: /[A-Z][a-zA-Z0-9_]*/

// keywords (all over ID)
_DATA.1: "data"
_FORALL.1: "forall"
INFIXL.2: "infixl" // over IN
INFIXR.2: "infixr" // over IN
_IN.1: "in"
_LET.1: "let"
_MATCH.1: "match"

ID: /[a-z_][a-zA-Z0-9_]*/

DEC: /(0|[1-9][0-9]*)\.[0-9]*/
NAT: /0|[1-9][0-9]*/

_BTICK: "`"
_BSLASH: "\\"
_COMMA: ","
_OCURLY: "{"
_CCURLY: "}"

_ARROW.1: "->" // over LARGE_OP
LARGE_OP: /[~!@$%^&*\/\-+|?.<>:=]{2,3}/

_COLON: ":"
_ASSIGN: "="
OP: /[~!@$%^&*\/\-+|?.<>]/

UNIT.1: "()" // over _OPAR
_OPAR: "("
_CPAR: ")"

SPACE: /[ \t\f\r\n]+/

%ignore COMMENT
%ignore SPACE
