// PARSER GRAMMAR

module: defn+

?defn: _DATA CAP_ID param_list? _OCURLY _INTERNAL _CCURLY   -> int_data_defn
     | _DATA CAP_ID param_list? _OCURLY datact_list _CCURLY -> data_defn
     | _LET _name param_list? _ASSIGN _internal             -> int_val_defn
     | _LET ID _operator ID _ASSIGN _internal               -> int_op_defn
     | local_defn

datact_list: datact+

datact: CAP_ID ( _COLON fun_type )?

full_type: ( _FORALL type_var_list DOT )? ( constr_list _IMPLY )? fun_type

quant_type: ( _FORALL type_var_list DOT )? fun_type

type_var_list: ID+

constr_list: constr+

constr: CAP_ID param_list

fun_type: type ( _ARROW type )*

?type: ( type_var | type_const ) _OPAR quant_type ( _COMMA quant_type )* _CPAR -> type_app
     | type_var
     | type_const
     | _OPAR quant_type _CPAR

type_var: ID

type_const: CAP_ID

_internal: _INTERNAL ID

?local_defn: ( INFIXL | INFIXR ) NAT _operator   -> fix_defn
           | _LET _name _COLON full_type         -> typeof_defn
           | _LET _name param_list? _ASSIGN expr -> val_defn
           | _LET ID _operator ID _ASSIGN expr   -> op_defn

_name: ID
     | _OPAR ( LARGE_OP | OP | DOT ) _CPAR

_operator: _BTICK ID _BTICK
         | LARGE_OP
         | OP
         | DOT

param_list: _OPAR ID ( _COMMA ID )* _CPAR

?expr: _BSLASH param_list _ASSIGN expr -> fun_expr
     | local_defn+ _IN expr            -> let_expr
     | operand ( _operator operand )*  -> op_chain_expr

match: pattern _ARROW expr

?pattern: ID                   -> capture_pattern
        | CAP_ID param_list?   -> data_pattern
        | ( DEC | NAT | UNIT ) -> literal_pattern

?operand: operand _OPAR expr_list _CPAR      -> fun_app
        | ( CAP_ID | _name )                 -> id_atom
        | _MATCH expr _OCURLY match+ _CCURLY -> match_expr
        | _OPAR expr _CPAR
        | literal

expr_list: expr ( _COMMA expr )*

?literal: DEC  -> dec_literal
        | NAT  -> nat_literal
        | UNIT -> unit_literal


// LEXER GRAMMAR

_INTERNAL.1: "#internal" // over COMMENT
COMMENT: /#[^\n]*/

CAP_ID: /[A-Z][a-zA-Z0-9_]*/

_DATA: "data"
_FORALL: "forall"
INFIXL: "infixl"
INFIXR: "infixr"
_IN: "in"
_LET: "let"
_MATCH: "match"

ID: /[a-z_][a-zA-Z0-9_]*/

DEC: /(0|[1-9][0-9]*)\.[0-9]*/
NAT: /0|[1-9][0-9]*/

_BTICK: "`"
_BSLASH: "\\"
_COMMA: ","
_OCURLY: "{"
_CCURLY: "}"

_ARROW: "->"
_IMPLY: "=>"
LARGE_OP: /[~!@$%^&*\/\-+|?.<>:=]{2,3}/

DOT: "."
_COLON: ":"
_ASSIGN: "="
OP: /[~!@$%^&*\/\-+|?<>]/

UNIT: "(" SPACE? ")"
_OPAR: "("
_CPAR: ")"

SPACE: /[ \t\f\r\n]+/

%ignore COMMENT
%ignore SPACE
