// PARSER GRAMMAR

module: glob_defn_list _SEMI?

glob_defn_list: glob_defn_list _SEMI glob_defn
              | glob_defn

?glob_defn: _name _ASSIGN _internal                             -> int_val_defn
          | _name param_list _ASSIGN _internal                  -> int_fun_defn
          | ID _operator ID _ASSIGN _internal                   -> int_op_defn
          | _DATA TYPE_ID _ASSIGN _INTERNAL                     -> int_adt_defn
          | _DATA TYPE_ID param_list? _ASSIGN _BAR? adt_ct_list -> adt_defn
          | defn

adt_ct_list: adt_ct_list _BAR adt_ct
           | adt_ct

adt_ct: TYPE_ID ( _COLON fun_type_arg )?

fun_type_arg: type_arg _ARROW fun_type_arg
            | type_arg

?type_arg: ID                       -> var_type_arg
         | TYPE_ID                  -> null_type_arg
         | TYPE_ID type_arg_list    -> poly_type_arg
         | _OPAR fun_type_arg _CPAR

type_arg_list: type_arg_list type_arg
             | type_arg

_internal: _INTERNAL ID

?defn: _name _ASSIGN _expr                   -> val_defn
     | _name param_list _ASSIGN _expr        -> fun_defn
     | ID _operator ID _ASSIGN _expr         -> op_defn
     | _name _COLON fun_type_arg             -> typeof_defn
     | ( INFIXL | INFIXR ) NAT operator_list -> fix_defn

_name: ID
     | _OPAR ( LARGE_OP | OP ) _CPAR

operator_list: operator_list _operator
             | _operator

_operator: _BTICK ID _BTICK
         | LARGE_OP
         | OP

param_list: param_list ID
          | ID

_expr: no_match_expr
     | match_expr

match_expr: _MATCH ( no_match_expr | _OPAR match_expr _CPAR ) match_list

?no_match_expr: _BSLASH param_list _ASSIGN _expr   -> func_expr
              | _DO action_list _SEMI? _THEN _expr -> block_expr
              | _LET defn_list _SEMI? _IN _expr    -> let_expr
              | _IF _expr _THEN _expr _ELSE _expr  -> cond_expr
              | op_chain                           -> op_chain_expr

action_list: action_list _SEMI _expr
           | _expr

defn_list: defn_list _SEMI defn
         | defn

match_list: match_list match
          | match

match: _BAR pattern _ARROW ( no_match_expr | _OPAR match_expr _CPAR )

?pattern: _single_pattern
        | TYPE_ID single_pattern_list? -> ct_pattern

_single_pattern: ID
               | literal

single_pattern_list: single_pattern_list _single_pattern
                   | _single_pattern

op_chain: op_chain _operator operand
        | operand

operand: operand atom
       | atom

?atom: _OPAR _expr _CPAR   -> expr_atom
     | ( TYPE_ID | _name ) -> id_atom
     | literal

?literal: DEC  -> dec_literal
        | NAT  -> nat_literal
        | BOOL -> bool_literal
        | UNIT -> unit_literal

// LEXER GRAMMAR

_INTERNAL.1: "#internal" // over COMMENT
COMMENT: /#[^\n]*/

TYPE_ID: /[A-Z][a-zA-Z0-9_]*/

// keywords (all over ID)
INFIXL.2: "infixl" // over IN
INFIXR.2: "infixr" // over IN
_IN.1: "in"
_LET.1: "let"
_THEN.1: "then"
_DO.1: "do"
_MATCH.1: "match"
_IF.1: "if"
_ELSE.1: "else"
_DATA.1: "data"
BOOL.1: "true" | "false"

ID: /[a-z_][a-zA-Z0-9_]*/

DEC: /(0|[1-9][0-9]*)\.[0-9]*/
NAT: /0|[1-9][0-9]*/

_BTICK: "`"
_BSLASH: "\\"
_SEMI: ";"

_ARROW.1: "->" // over LARGE_OP
LARGE_OP: /[~!@$%^&*\/\-+|?.<>:=]{2,3}/
_ASSIGN: "="
_BAR: "|"
_COLON: ":"
OP: /[~!@$%^&*\/\-+?.<>]/

UNIT: "()"

_OPAR: "("
_CPAR: ")"

SPACE: /[ \t\f\r\n]+/

%ignore COMMENT
%ignore SPACE
