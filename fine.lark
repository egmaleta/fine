// PARSER GRAMMAR

module: glob_defn_list

glob_defn_list: glob_defn_list glob_defn
              | glob_defn

?glob_defn: _LET _name _ASSIGN _external            -> ext_val_defn
          | _LET _name param_list _ASSIGN _external -> ext_fun_defn
          | _LET ID _operator ID _ASSIGN _external  -> ext_op_defn
          | poly_type_defn
          | type_defn
          | defn

poly_type_defn: _TYPE TYPE_ID param_list _ASSIGN ( _BAR? data_ct_list | _EXTERNAL )

type_defn: _TYPE TYPE_ID _ASSIGN ( _BAR? data_ct_list | _EXTERNAL )

data_ct_list: data_ct_list _BAR data_ct
            | data_ct

data_ct: TYPE_ID ( _COLON fun_type_arg )?

fun_type_arg: type_arg ARROW fun_type_arg
            | type_arg

?type_arg: ID                       -> var_type_arg
         | TYPE_ID                  -> null_type_arg
         | TYPE_ID type_arg_list    -> poly_type_arg
         | _OPAR fun_type_arg _CPAR

type_arg_list: type_arg_list type_arg
             | type_arg

_external: _EXTERNAL ID

?defn: _LET _name _ASSIGN _expr              -> val_defn
     | _LET _name param_list _ASSIGN _expr   -> fun_defn
     | _LET ID _operator ID _ASSIGN _expr    -> op_defn
     | _LET _name _COLON fun_type_arg        -> typeof_defn
     | ( INFIXL | INFIXR ) NAT operator_list -> fix_defn

_name: ID
     | _OPAR ( LARGE_OP | OP ) _CPAR

operator_list: operator_list _operator
             | _operator

_operator: _BTICK ID _BTICK
         | LARGE_OP
         | OP

param_list: param_list ID
          | ID

_expr: no_match_expr
     | match_expr

match_expr: _MATCH ( no_match_expr | _OPAR match_expr _CPAR ) match_list

?no_match_expr: _BSLASH param_list? _ASSIGN _expr  -> func_expr
              | _DO action_list _SEMI? _THEN _expr -> block_expr
              | defn_list _IN _expr                -> let_expr
              | _IF _expr _THEN _expr _ELSE _expr  -> cond_expr
              | op_chain                           -> op_chain_expr

action_list: action_list _SEMI _expr
           | _expr

defn_list: defn_list defn
         | defn

match_list: match_list match
          | match

match: _BAR pattern ARROW ( no_match_expr | _OPAR match_expr _CPAR )

?pattern: ID      -> id_pattern
        | TYPE_ID -> ct_pattern
        | literal

op_chain: op_chain _operator operand
        | operand

operand: operand atom
       | atom

?atom: _OPAR _expr _CPAR   -> expr_atom
     | ( TYPE_ID | _name ) -> id_atom
     | literal

?literal: DEC  -> dec_literal
        | NAT  -> nat_literal
        | BOOL -> bool_literal
        | UNIT -> unit_literal

// LEXER GRAMMAR

_EXTERNAL.1: "#external" // over COMMENT
COMMENT: /#[^\n]*/

TYPE_ID: /[A-Z][a-zA-Z0-9_]*/

// keywords (all over ID)
INFIXL.2: "infixl" // over IN
INFIXR.2: "infixr" // over IN
_IN.1: "in"
_LET.1: "let"
_THEN.1: "then"
_DO.1: "do"
_MATCH.1: "match"
_IF.1: "if"
_ELSE.1: "else"
_TYPE.1: "type"
BOOL.1: "true" | "false"

ID: /[a-z_][a-zA-Z0-9_]*/

DEC: /(0|[1-9][0-9]*)\.[0-9]*/
NAT: /0|[1-9][0-9]*/

_BTICK: "`"
_BSLASH: "\\"
_SEMI: ";"

ARROW.1: "->" // over LARGE_OP
LARGE_OP: /[~!@$%^&*\/\-+|?.<>:=]{2,3}/
_ASSIGN: "="
_BAR: "|"
_COLON: ":"
OP: /[~!@$%^&*\/\-+?.<>]/

UNIT: "()"

_OPAR: "("
_CPAR: ")"

SPACE: /[ \t\f\r\n]+/

%ignore COMMENT
%ignore SPACE
