// PARSER GRAMMAR

module: glob_defn+

?glob_defn: _LET _name _ASSIGN _internal                                  -> int_val_defn
          | _LET _name param_list _ASSIGN _internal                       -> int_fun_defn
          | _LET ID _operator ID _ASSIGN _internal                        -> int_op_defn
          | _DATA TYPE_ID param_list? _OCURLY _INTERNAL _CCURLY           -> int_adt_defn
          | _DATA TYPE_ID param_list? _OCURLY adt_ct_list _COMMA? _CCURLY -> adt_defn
          | defn

adt_ct_list: adt_ct ( _COMMA adt_ct )*

adt_ct: TYPE_ID ( _COLON quantified_type )?

quantified_type: ( _FORALL param_list DOT )? fun_type

fun_type: _type ( _ARROW _type )*

_type: type_var
     | mono_type
     | poly_type
     | _OPAR quantified_type _CPAR

type_var: ID

mono_type: TYPE_ID

poly_type: ( ID | TYPE_ID ) _type_arg+

_type_arg: type_var
         | mono_type
         | _OPAR poly_type _CPAR
         | _OPAR quantified_type _CPAR

_internal: _INTERNAL ID

?defn: _LET _name _ASSIGN expr            -> val_defn
     | _LET _name param_list _ASSIGN expr -> fun_defn
     | _LET ID _operator ID _ASSIGN expr  -> op_defn
     | _LET _name _COLON quantified_type  -> typeof_defn
     | ( INFIXL | INFIXR ) NAT _operator+ -> fix_defn

_name: ID
     | _OPAR ( LARGE_OP | OP | DOT ) _CPAR

_operator: _BTICK ID _BTICK
         | LARGE_OP
         | OP
         | DOT

param_list: ID+

?expr: _BSLASH param_list _ASSIGN expr                             -> func_expr
     | defn+ _IN expr                                              -> let_expr
     | _MATCH expr _OCURLY match ( _COMMA match )* _COMMA? _CCURLY -> match_expr
     | operand ( _operator operand )*                              -> op_chain_expr

match: pattern _ARROW expr

?pattern: capture_pattern
        | TYPE_ID capture_pattern* -> data_pattern
        | ( DEC | NAT | UNIT )     -> literal_pattern

capture_pattern: ID

operand: operand atom
       | atom

?atom: _OPAR expr _CPAR    -> expr_atom
     | ( TYPE_ID | _name ) -> id_atom
     | literal

?literal: DEC  -> dec_literal
        | NAT  -> nat_literal
        | UNIT -> unit_literal

// LEXER GRAMMAR

_INTERNAL.1: "#internal" // over COMMENT
COMMENT: /#[^\n]*/

TYPE_ID: /[A-Z][a-zA-Z0-9_]*/

// keywords (all over ID)
INFIXL.2: "infixl" // over IN
INFIXR.2: "infixr" // over IN
_FORALL.1: "forall"
_IN.1: "in"
_LET.1: "let"
_MATCH.1: "match"
_DATA.1: "data"

ID: /[a-z_][a-zA-Z0-9_]*/

DEC: /(0|[1-9][0-9]*)\.[0-9]*/
NAT: /0|[1-9][0-9]*/

_BTICK: "`"
_BSLASH: "\\"
_COMMA: ","
_OCURLY: "{"
_CCURLY: "}"

_ARROW.1: "->" // over LARGE_OP
LARGE_OP: /[~!@$%^&*\/\-+|?.<>:=]{2,3}/
_ASSIGN: "="
_BAR: "|"
_COLON: ":"
DOT: "."
OP: /[~!@$%^&*\/\-+?<>]/

UNIT: "()"

_OPAR: "("
_CPAR: ")"

SPACE: /[ \t\f\r\n]+/

%ignore COMMENT
%ignore SPACE
